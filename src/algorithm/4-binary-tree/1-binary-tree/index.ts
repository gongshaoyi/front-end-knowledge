/** 二叉树（纲领篇）*/

// 先在开头总结一下，二叉树解题的思维模式分两类：

// 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个traverse函数配合外部变量来实现，这叫「遍历」的思维模式。

// 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

// 无论使用哪种思维模式，你都需要思考：

// 如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

// 本文中会用题目来举例，但都是最最简单的题目，所以不用担心自己看不懂，我可以帮你从最简单的问题中提炼出所有二叉树题目的共性，
// 并将二叉树中蕴含的思维进行升华，反手用到 动态规划，回溯算法，分治算法，图论算法 中去，这也是我一直强调框架思维的原因。

// 首先，我还是要不厌其烦地强调一下二叉树这种数据结构及相关算法的重要性。

/* 二叉树的重要性 */

// 举个例子，比如两个经典排序算法 快速排序 和 归并排序，对于它俩，你有什么理解？

// 如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了。

// 为什么快速排序和归并排序能和二叉树扯上关系？我们来简单分析一下他们的算法思想和代码框架：

// 快速排序的逻辑是，若要对nums[lo..hi]进行排序，我们先找一个分界点p，
// 通过交换元素使得nums[lo..p-1]都小于等于nums[p]，且nums[p+1..hi]都大于nums[p]，
// 然后递归地去nums[lo..p-1]和nums[p+1..hi]中寻找新的分界点，最后整个数组就被排序了。

// 快速排序的代码框架如下：
const partition = (nums: number[], lo: number, hi: number) => 1; // 防止ts报错
const quickSort = (nums: number[], lo: number, hi: number) => {
	// 前序遍历位置
	// 通过交换元素构建分界点p
	const p = partition(nums, lo, hi);
	quickSort(nums, lo, p - 1);
	quickSort(nums, p + 1, hi);
};

// 先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？

// 再说说归并排序的逻辑，若要对nums[lo..hi]进行排序，我们先对nums[lo..mid]排序，再对nums[mid+1..hi]排序，最后把这两个有序的子数组合并，整个数组就排好序了。

// 归并排序的代码框架如下：
const merge = (nums: number[], lo: number, mid: number, hi: number) => {}; // 防止ts报错
const mergeSort = (nums: number[], lo: number, hi: number) => {
	const mid = Math.floor((lo + hi) / 2);
	// 排序lo到mid
	mergeSort(nums, lo, mid);
	// 排序mid+1到hi
	mergeSort(nums, mid + 1, hi);
	// 后序位置，合并nums[lo...mid]和nums[mid+1...hi]
	merge(nums, lo, mid, hi);
};

// 先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。

// 如果你一眼就识破这些排序算法的底细，还需要背这些经典算法吗？不需要。你可以手到擒来，从二叉树遍历框架就能扩展出算法了。

// 说了这么多，旨在说明，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题。

// 接下来我们从二叉树的前中后序开始讲起，让你深刻理解这种数据结构的魅力。

/* 深入理解前中后序 */

// 我先甩给你几个问题，请默默思考 30 秒：

// 1、你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的 List 吗？

// 2、请分析，后序遍历有什么特殊之处？

// 3、请分析，为什么多叉树没有中序遍历？

// 答不上来，说明你对前中后序的理解仅仅局限于教科书，不过没关系，我用类比的方式解释一下我眼中的前中后序遍历。

// 首先，回顾一下 学习数据结构和算法的框架思维 中说到的二叉树遍历框架：

type TreeNode = {
	val: unknown;
	left: TreeNode | null;
	right: TreeNode | null;
};
const traverse_1 = (root: TreeNode) => {
	if (root === null) {
		return;
	}
	// 前序位置
	traverse_1(root.left);
	// 中序位置
	traverse_1(root.right);
	// 后序位置
};

// 先不管所谓前中后序，单看traverse函数，你说它在做什么事情？

// 其实它就是一个能够遍历二叉树所有节点的一个函数，和你遍历数组或者链表本质上没有区别：

// 迭代遍历数组
const traverse_arr_1 = (arr: unknown[]) => {
	for (let i = 0; i < arr.length; i++) {
		// 操作
	}
};

// 递归遍历数组
const traverse_arr_2 = (arr: unknown[], i: number) => {
	if (arr.length === i) {
		return;
	}
	// 前序位置
	traverse_arr_2(arr, i + 1);
	// 后序位置
};

type ListNode = {
	val: unknown;
	next: ListNode | null;
};
// 迭代遍历链表
const traverse_list_1 = (list: ListNode) => {
	for (let p = list; p !== null; p = p.next) {
		//操作
	}
};

// 递归遍历链表
const traverse_list_2 = (list: ListNode) => {
	if (list === null) {
		return;
	}
	// 前序位置
	traverse_list_2(list.next);
	// 后续位置
};

// 单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。

// 你也注意到了，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。

// 所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，那么进一步，你把代码写在不同位置，代码执行的时机也不同：image/image1

// 比如说，如果让你倒序打印一条单链表上所有节点的值，你怎么搞？

// 实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作：

const traverse_list_3 = (head: ListNode) => {
	if (head === null) {
		return;
	}
	traverse_list_3(head.next);
	// 后序位置
	console.log(head.val);
};

// 结合上面那张图，你应该知道为什么这段代码能够倒序打印单链表了吧，本质上是利用递归的堆栈帮你实现了倒序遍历的效果。

// 那么说回二叉树也是一样的，只不过多了一个中序位置罢了。

// 教科书里只会问你前中后序遍历结果分别是什么，所以对于一个只上过大学数据结构课程的人来说，他大概以为二叉树的前中后序只不过对应三种顺序不同的List<Integer>列表。

// 但是我想说，前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：

// 前序位置的代码在刚刚进入一个二叉树节点的时候执行；

// 后序位置的代码在将要离开一个二叉树节点的时候执行；

// 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

// 你注意本文的用词，我一直说前中后序「位置」，就是要和大家常说的前中后序「遍历」有所区别：
// 你可以在前序位置写代码往一个 List 里面塞元素，那最后得到的就是前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事。

// 画成图，前中后序三个位置在二叉树上是这样：image/image2

// 你可以发现每个节点都有「唯一」属于自己的前中后序位置，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。

// 这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，
// 而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。

// 说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现：

// 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，
// 你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

// 你也可以看到，图论算法基础 把二叉树的遍历框架扩展到了图，并以遍历为基础实现了图论的各种经典算法，不过这是后话，本文就不多说了。

/** 两种解题思路 */

// 前文 我的算法学习心得 说过：

// 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。

// 当时我是用二叉树的最大深度这个问题来举例，重点在于把这两种思路和动态规划和回溯算法进行对比，而本文的重点在于分析这两种思路如何解决二叉树的题目。

// 力扣第 104 题「二叉树的最大深度」就是最大深度的题目，所谓最大深度就是根节点到「最远」叶子节点的最长路径上的节点数，比如输入这棵二叉树，算法应该返回 3：image/image3

// 你做这题的思路是什么？显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，这就是遍历二叉树计算答案的思路。

// 解法代码如下：

const maxDepth_1 = (root: TreeNode) => {
	// 遍历记录节点深度
	let depth = 0;
	// 记录最大深度
	let res = 0;

	// 二叉树遍历框架
	const traverse = (root: TreeNode) => {
		if (root === null) {
			// 到达叶子结点更新最大深度
			res = Math.max(res, depth);
			return;
		}

		// 前序位置
		depth++;
		traverse(root.left);
		traverse(root.right);
		// 后序位置
		depth--;
	};
};

// 这个解法应该很好理解，但为什么需要在前序位置增加depth，在后序位置减小depth？

// 因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，
// depth记录当前递归到的节点深度，你把traverse理解成在二叉树上游走的一个指针，所以当然要这样维护。

// 当然，你也很容易发现一棵二叉树的最大深度可以通过子树的最大高度推导出来，这就是分解问题计算答案的思路。

// 解法代码如下：

const maxDepth_2 = (root: TreeNode): number => {
	if (root === null) {
		return 0;
	}

	// 计算左右子树的最大深度
	const leftMax = maxDepth_2(root.left);
	const rightMax = maxDepth_2(root.right);

	// 最大深度等于左右子树的最大深度的最大值加上根节点自己
	const res = Math.max(leftMax, rightMax) + 1;

	return res;
};

// 只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？

// 因为这个思路正确的核心在于，你确实可以通过子树的最大高度推导出原树的高度，
// 所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。

// 如果你理解了最大深度这个问题的两种思路，那么我们再回头看看最基本的二叉树前中后序遍历，就比如算前序遍历结果吧。

// 我们熟悉的解法就是用「遍历」的思路，我想应该没什么好说的：

const preOrderTravers_1 = (root: TreeNode) => {
	let res: unknown[] = [];
	const traverse = (root: TreeNode) => {
		if (root === null) {
			return;
		}

		res.push(root.val);
		traverse(root.left);
		traverse(root.right);
	};

	traverse(root);

	return res;
};

// 但你是否能够用「分解问题」的思路，来计算前序遍历的结果？

// 换句话说，不要用像traverse这样的辅助函数和任何外部变量，单纯用题目给的preorderTraverse函数递归解题，你会不会？

// 我们知道前序遍历的特点是，根节点的值排在首位，接着是左子树的前序遍历结果，最后是右子树的前序遍历结果：image/image4

// 那这不就可以分解问题了么，一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果。

// 所以，你可以这样实现前序遍历算法：

const preOrderTravers_2 = (root: TreeNode) => {
	let res: unknown[] = [];
	if (root === null) {
		return res;
	}
	res.push(root.val);
	const left = preOrderTravers_2(root.left);
	const right = preOrderTravers_2(root.right);
	res.concat(left, right);

	return res;
};

// 中序和后序遍历也是类似的，只要把add(root.val)放到中序和后序对应的位置就行了。

// 这个解法短小精干，但为什么不常见呢？

// 一个原因是这个算法的复杂度不好把控，比较依赖语言特性。

// 当然，最主要的原因还是因为教科书上从来没有这么教过……

// 上文举了两个简单的例子，但还有不少二叉树的题目是可以同时使用两种思路来思考和求解的，这就要靠你自己多去练习和思考，不要仅仅满足于一种熟悉的解法思路。

// 综上，遇到一道二叉树的题目时的通用思考过程是：

// 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个traverse函数配合外部变量来实现。

// 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

// 3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。

/* 后序位置的特殊之处 */

// 说后序位置之前，先简单说下中序和前序。

// 中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。

// 前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。

// 你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：image/image5

// 这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。

// 但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。

// 举具体的例子，现在给你一棵二叉树，我问你两个简单的问题：

// 1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

// 2、如何打印出每个节点的左右子树各有多少节点？

// 第一个问题可以这样写代码：

const traverse_11 = (root: TreeNode, level: number = 1) => {
	if (root === null) {
		return;
	}

	// 前序位置
	console.log(`节点${root.val}在第${level}层`);
	traverse_11(root.left, level + 1);
	traverse_11(root.right, level + 1);
};
// 调用
// traverse_11(root,1)

// 第二个问题可以这样写代码：

const count = (root: TreeNode): number => {
	if (root === null) {
		return 0;
	}

	const left = count(root.left);
	const right = count(root.right);

	// 后序位置
	console.log(`节点${root.val}左子树有${left}个节点，右子树有${right}个节点`);

	return left + right + 1;
};

// 这两个问题的根本区别在于：一个节点在第几层，你从根节点遍历过来的过程就能顺带记录；
// 而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚。

// 结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。

// 那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。

// 接下来看下后序位置是如何在实际的题目中发挥作用的，简单聊下力扣第 543 题「二叉树的直径」，让你计算一棵二叉树的最长直径长度。

// 所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度。最长「直径」并不一定要穿过根结点，比如下面这棵二叉树：image/image6

// 它的最长直径是 3，即[4,2,1,3]或者[5,2,1,3]这两条「直径」的长度。

// 解决这题的关键在于，每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和。

// 现在让我求整棵树中的最长「直径」，那直截了当的思路就是遍历整棵树中的每个节点，
// 然后通过每个节点的左右子树的最大深度算出每个节点的「直径」，最后把所有「直径」求个最大值即可。

// 最大深度的算法我们刚才实现过了，上述思路就可以写出以下代码：

const diameterOfBinaryTree_1 = (root: TreeNode) => {
	let maxDiameter = 0;

	const traverse = (root: TreeNode) => {
		if (root === null) {
			return;
		}

		// 对每个节点计算直径
		const leftMax = maxDepth_2(root.left);
		const rightMax = maxDepth_2(root.right);
		const myDiameter = leftMax + rightMax + 1;
		maxDiameter = Math.max(maxDiameter, myDiameter);

		traverse(root.left);
		traverse(root.right);
	};
};

// 这个解法是正确的，但是运行时间很长，原因也很明显，traverse遍历每个节点的时候还会调用递归函数maxDepth，而maxDepth是要遍历子树的所有节点的，所以最坏时间复杂度是 O(N^2)。

// 这就出现了刚才探讨的情况，前序位置无法获取子树信息，所以只能让每个节点调用maxDepth函数去算子树的深度。

// 那如何优化？我们应该把计算「直径」的逻辑放在后序位置，准确说应该是放在maxDepth的后序位置，因为maxDepth的后序位置是知道左右子树的最大深度的。

// 所以，稍微改一下代码逻辑即可得到更好的解法：

const diameterOfBinaryTree_2 = (root: TreeNode) => {
	let maxDiameter = 0;
	const maxDepth = (root: TreeNode): number => {
		if (root === null) {
			return 0;
		}
		const leftMax = maxDepth(root.left);
		const rightMax = maxDepth(root.right);
		let myDiameter = leftMax + rightMax + 1;
		maxDiameter = Math.max(maxDiameter, myDiameter);

		return 1 + Math.max(leftMax, rightMax);
	};
	maxDepth(root);

	return maxDiameter;
};

// 这下时间复杂度只有maxDepth函数的 O(N) 了。

// 讲到这里，照应一下前文：遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。

// 反过来，如果你写出了类似一开始的那种递归套递归的解法，大概率也需要反思是不是可以通过后序遍历优化了。

/* 层序遍历 */

// 二叉树题型主要是用来培养递归思维的，而层序遍历属于迭代遍历，也比较简单，这里就过一下代码框架吧：

const levelTraverse = (root: TreeNode) => {
	if (root === null) {
		return;
	}
	const queue: TreeNode[] = [];
	queue.push(root);

	// 从上到下遍历二叉树的每一层
	while (queue.length > 0) {
		const len = queue.length;
		// 从左往右遍历该层的所有节点
		for (let i = 0; i < len; i++) {
			const cur = queue.shift();
			if (cur.left) {
				queue.push(cur.left);
			}
			if (cur.right) {
				queue.push(cur.right);
			}
		}
	}
};

// 这里面 while 循环和 for 循环分管从上到下和从左到右的遍历：image/image7

// 前文 BFS 算法框架 就是从二叉树的层序遍历扩展出来的，常用于求无权图的最短路径问题。

// 当然这个框架还可以灵活修改，题目不需要记录层数（步数）时可以去掉上述框架中的 for 循环，
// 比如前文 Dijkstra 算法 中计算加权图的最短路径问题，详细探讨了 BFS 算法的扩展。

// 值得一提的是，有些很明显需要用层序遍历技巧的二叉树的题目，也可以用递归遍历的方式去解决，而且技巧性会更强，非常考察你对前中后序的把控。
